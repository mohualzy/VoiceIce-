# 简介
此笔记主要用来介绍C语言中常见定义、概念等[八股文](https://m.baidu.com/bh/m/detail/ar_9957851422018903135)知识

# 关键字和标识符
很简单，但总有人搞混
int、float、double这些定义数据类型的是关键字
变量名（如index、score）等是标识符

# 精度问题
由于计算机语言为二进制，所以在我们输入一些浮点数时，可能会出现一些反直觉的误差
- 例如：
```
float a = 0.0f;
for (int i = 0; i < 100; i++)
	a += 0.1;
printf("%.1f", a);
```
是不是觉得答案应该是10？这样你就太年轻了，因为每个0.1存进计算机里面都可能失去了它原本的面貌，可能变成了0.10000000001，亦可能是0.9999999999，全凭编译器的心情
![Pasted image 20251115193654.png](picture/Pasted%20image%2020251115193654.png)
因此，在我们进行浮点数运算或比较时，时刻要记得设置一个误差值

# 类型转换
整数型和浮点型的转换是C语言初学者比较头痛的一件事（当然你们已经是高手了），遵循顺序原则（即先运算，再赋给变量，变量根据自身数据类型进行存储）。来看一道练习题。

**下列选项正确的是?**

- [] A. int a = 1.0 / 2 ;printf("%d, a")，结果为0
- [] B. int a = 1.0 / 2 ;printf("%.1f, a")，结果为0.5
- [] C. int a = 1, b = 2;float c = a / b; printf("%.1f, c), 结果为0.5
<details>
<summary>点击查看答案</summary>
	正确答案是A，你答对了吗？
</details>

**再补充一道拓展题，请读者自行思考。**
- int a = 1, b = 2; double c = (double)a / b;printf("%.1f, c")   结果为？
- int a = 1, b = 2; double c = (double)(a / b);printf("%.1f, c")   结果为？

**另**：***char类型储存的整数参与计算时隐式转为int型***

# 自增/自减运算符的细节(important!)
  **a++和++a的运算顺序极其关键，用两个例子来理解**
- while（a++ < 4）printf a会先判断a是否<4，再输出a+1的值；但while（++a）会先判断a+1是否小于4，再输出a+1的值
- int index = 0; arr\[index++]会先从arr\[0]开始，然后index再加1；而arr\[++index]会先把index加1，然后直接从arr\[1]开始

# “=” 和“\==”
**例题：下列代码的输出是（）**

```
#include <stdio.h>
int main() {
    int x = 10;
    if (x = 5) {
        printf("笨蛋");
    } else {
        printf("大聪明");
    }
    return 0;
}
```
- [] A. 笨蛋
- [] B. 大聪明
<details>
<summary>点击查看答案</summary>
	正确答案是A，你是笨蛋还是大聪明呢？<br>---
	请注意if里是把5赋给了x，而不是比较语句哦，赋值语句默认为真
</details>

# scanf的返回值

*scanf也有返回值，如果输入格式正确，有几个变量就是几*
- 如scanf("%d", a) == 1
- scanf("%d %f", a, b) == 2
如果输的格式有问题，则取之前输入格式正确的变量个数为返回值
- 如int b = scanf("%d", a)，如果之后输入q作为a的值（格式错误），则b为0
- int b = scanf("%d %d", a, c)，如果a输入的是整数，而c输入的不是整数（格式错误），则b为1；调换a，c顺序b就为0

# 形参与实参
*形参全名为形式参数，是调用函数里的“假”参数，而实参为main主函数里的“真”参数,C语言为值传递，函数内修改形参不会影响实参*
举一个例子

**以下代码的输出是**

```
#include <stdio.h>
void change(int x) {
    x = 100;
}
int main() {
    int a = 10;
    change(a);
    printf("%d", a);
    return 0;
}
```
- [] A. 10
- [] B. 100
- [] C. random
<details>
<summary>点击查看答案</summary>
	正确答案是A，你答对了吗？
</details>

**如果还是不能理解的话，想象一下：**
- 徐筱佩有一本书《西施怎么打对抗路》（变量a）
- 张乐冉想看，徐复印了一份（形参x）给他（值传递）
- 张乐冉在复印件上做笔记（修改形参x）
- 徐筱佩的原书还是原来的面貌，画着小张cos水晶的样子（实参a不变）

# 数组初始化细节

如果我定义了一个数组int arr\[5],但我不赋值，那么arr里的元素会自动填充为0
- 如int arr\[5] = {1}，那么除了arr\[0]为1以外，arr1、2、3、4全为0
[C语言常见问题——数组初始化的四种方法_c语言数组初始化-CSDN博客](https://blog.csdn.net/a26013/article/details/121767634)

# 二进制补码与内存存储(拓展)

## 字节和位
字节是计算机中数据处理的基本单位，而位（比特）顾名思义就是一个数位
比如1个字节等于8个比特，那么1字节就可储存从00000000到11111111的所有整数
## 补码
你可能会想，那么负数该怎么存储呢，难不成在前面加个负号？
其实不是的，在计算机中，负数一般用补码的形式来存储
**具体方法：取反加一**

1. 写出该负数的绝对值的二进制形式
2. 对所有位取反（0变1，1变0）
3. 对取反后的结果加1
---
**例如：求-6的8位补码**

1. 6的8位补码：00000110 
2. 取反：11111001
3. 加1：11111010

所以-6的8位补码是11111010

## 位运算

位运算是直接对整数的二进制位进行操作的运算：

### 基本位运算符：

1. **按位与 (&)**：
    
    - 两位都为1时结果为1，否则为0
        
    - 示例：5 & 3 = 101 & 011 = 001 = 1
        
2. **按位或 (|)**：
    
    - 两位有任一为1时结果为1
        
    - 示例：5 | 3 = 101 | 011 = 111 = 7
        
3. **按位异或 (^)**：
    
    - 两位不同时结果为1，相同时为0
        
    - 示例：5 ^ 3 = 101 ^ 011 = 110= 6
        
4. **按位取反 (~)**：
    
    - 所有位取反（0变1，1变0）
        
    - 示例：~5 = ~00000101 = 11111010 = -6（补码）
        
5. **左移 (<<)**：
    
    - 所有位向左移动，低位补0
        
    - 示例：5 << 1 = 101 → 1010 = 10
6. **右移 (>>)**：
    
    - 所有位向右移动，高位补符号位（算术右移）
        
    - 示例：-7 >> 1 = 11111001 → 11111100 = -4

至于用处？no idea！先背再说！

## char与int
众所周知，char类型可以存储字母和数字，但无论如何，它都只占一个字节，也就是8位，
实际存储数字的范围就为-128~127，例如char ch = -6，那么ch内存存储的二进制形式则为11111010；
而int一般占4个字节，也就是32位，实际存储数字的范围就是-2\*\*31 ~ 2\*\*31 - 1，例如int a = 6，那么a存储的二进制形式则为11111111  11111111  11111111 11111010

好了，我们已经差不多讲完了内存存储的最基本概念，现在让我们来一道题目练练手吧！

**已知char ch = 249; int a = ch
     请写出ch和i内存存储的二进制形式**

<details>
<summary>点击查看答案</summary>
	ch的二进制形式：11111001  <br>
	a的二进制形式：11111111 11111111 11111111 11111001
</details>

***易错点：***
char类型最大储存127，而249已超出范围。如果赋给它128，那么它实际存的十进制形式为-128（0~127，然后-128~0，一直循环下去）。于是我们知道赋值249时ch存的实际上是-7，然后再转成二进制形式

# 笔记到此就告一段落了，看到这了还不给个三连吗（doge）
[C语言基础选择题100道（附答案）01_c语言选择题-CSDN博客](https://blog.csdn.net/Su_mer/article/details/122684378)*(觉得不够可以再刷)*